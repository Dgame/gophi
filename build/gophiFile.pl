:- encoding(utf8).

% parses the command line to parse a file of AMRs in the LDC format (ending with .txt)
%           and produce an output file (ending with .out)
%           which is used to create an Excel file (ending with .xlsx)  
%  called as amr2eng [--regex filtering_regex] [--show] [--help] amrs.txt 
:-use_module(library(optparse)).
optsSpecs([
           [opt(regex),type(atom),default(''), shortflags([r]),longflags([regex]), 
            help(['regular expression for filtering AMR ', '(in dotall mode)'])],
           [opt(show),type(boolean),default(false),
            longflags([show]),help(['show intermediary structures'])],
           [opt(help),type(boolean),default(false),shortflags([h]),
            longflags([help]),help('show help and stop')],
           [opt(file),default('amrs.txt'), help(['file containing AMRs'])]
          ]).

getParams(Args,FileName):-
    current_prolog_flag(argv,ARGV),
    optsSpecs(OptsSpec),
    opt_parse(OptsSpec, ARGV, Args,FileName).

%%%%%%%%%%%%%%%%%%%%%%%%%%
%%  start of parsing
%%
:- dynamic currentAMR/2.

:-['utils'].
:-['parse'].
:-['dictionary'].
:-['deepSyntR'].
:-['surfSyntR'].
:-['reification'].
:-['gophi'].

start :- getParams(Args,FileName),
    (% show help if -h or --help
     member(help(true),Args)->(optsSpecs(OptsSpecs),opt_help(OptsSpecs,Help),writeln(Help));
     % deal with other args otherwise
     FileName=[InFileName],
     memberchk(regex(Regex),Args),
     (Regex=''->re_replace('.txt$','.out',InFileName,OutFileName);
                format(atom(Ext),'-~w.out',[Regex]),
                re_replace('.txt$',Ext,InFileName,OutFileName)),
     memberchk(show(Show),Args),
     parseFile(InFileName,OutFileName,Regex,Show),
     atomic_list_concat(['python3 ../tools/amrStats.py',OutFileName],' ',Command),
     shell(Command,Exit),
     (Exit = 0 -> 
         re_replace('.out$','.xlsx',OutFileName,XslFileName),
         (writeln('Excel file created':XslFileName);
          writeln('exit code':Exit:' Problem in creating excel file':XslFileName)))
    ).

%% Process a file of many AMRs

parseFile(InFileName,OutFileName,Regex,Show):-
    open(InFileName,read,InFile),
    open(OutFileName,write,OutFile,[encoding(utf8)]),
    get_time(Time),
    format_time(OutFile,'# AMRs generated by Γω-Φ (gophi) on %F at %T\n\n',Time),
    time(gophiFile(InFile,OutFile,Regex,Show)),
    close(OutFile).


% check the type of a line
isId(Line,Id)    :-re_matchsub('^# +::id ([-\\w\\.]+)',Line,X,[]),  Id=X.1.
isSent(Line,Sent):-re_matchsub('^# +::snt (.+)',Line,X,[]), Sent=X.1.
isComment(Line)  :-re_match('^#',Line).
isEmpty(Line)    :-re_match('^\s*$',Line).

%% read a group of lines until an empty one or end of file (Eof=true)
group(In,[Line|Lines],Eof):-
    read_string(In,"\n", "\r", End, Line),
    (End = -1 ->Lines=[],Eof=true;
     (isEmpty(Line) -> Lines=[],Eof=false;
      group(In,Lines,Eof))).

%% transform a group of Lines and create an AMR structure
makeAMR([],(noId,[],noSent,[])).
makeAMR([Line|Lines],AMR):-
    isEmpty(Line),!,makeAMR(Lines,AMR).
makeAMR([Line|Lines],(Id,AMRtext,NewSent,[Line|Header])):-
    isSent(Line,NewSent),!,makeAMR(Lines,(Id,AMRtext,_Sent,Header)).
makeAMR([Line|Lines],(NewId,AMRtext,Sent,[Line|Header])):-
    isId(Line,NewId),!,makeAMR(Lines,(_Id,AMRtext,Sent,Header)).
makeAMR([Line|Lines],(Id,AMRtext,Sent,[Line|Header])):-
    isComment(Line),!,makeAMR(Lines,(Id,AMRtext,Sent,Header)).
makeAMR([Line|Lines],(Id,[Line|AMRtext],Sent,Header)):-
    makeAMR(Lines,(Id,AMRtext,Sent,Header)).

gophiFile(InFile,OutFile,RegEx,Show):-
    group(InFile,Group,Eof),
    makeAMR(Group,(Id,AMRLines,Sent,HeaderLines)),
    atomic_list_concat(AMRLines,'\n',AMRstring),
    atomic_list_concat(HeaderLines,'\n',Header),
    (isEmpty(AMRstring)->% only copy header if no AMR appears within the group and recurse
        writeln(OutFile,Header),write(OutFile,'\n'),gophiFile(InFile,OutFile,RegEx,Show); 
        %% else if Regex is a number (usually  between 0 and 1), process with this prob 
        %% else write the target sentence and check if matches the regex
       (number(RegEx)->maybe(RegEx);re_match(RegEx,AMRstring)),
        format('~s~s~s~s~n~s~n',['--- ',Id,':',Sent,AMRstring]),
        (amr2SSyntR(AMRstring,SSyntR,Show,false),
         jsRealB(SSyntR,GenSent),
         writeln('> English sentence'),
         writeln(GenSent),
         amr2BaseGen(AMRstring,BaseGen),
         (current_stream([],write,OutFile)->true; % do not write this if OutFile is stdout
            format(OutFile,'~s~n# ::gophi ~s~n# ::basegen ~s~n~s~n~n',
                  [Header,GenSent,BaseGen,AMRstring])),
        (Eof->true; % stop if at end of file
            % else recurse to continue with the next AMR
            gophiFile(InFile,OutFile,RegEx,Show)))
        ;
        format('***:error in processing this AMR')
    ).
        
%%% useful shorcuts for testing in the Swipl console
%  show all steps of transformation
showAMRsFile(InFileName,Regex):-
    open(InFileName,read,In),
    current_output(Out),
    gophiFile(In,Out,Regex,true).

%% show only the input AMR and the final realisation
showRealisation(InFileName,Regex):-
    open(InFileName,read,In),
    open_null_stream(Out),
    gophiFile(In,Out,Regex,false).

testParseFile:-
    open('../amr-examples/amr-examples.txt',read,In),
    open('../amr-examples/amr-examples-test.out',write,Out),
    gophiFile(In,Out,'',true).
